![run-tests](../../workflows/run-tests/badge.svg)

## 2020 Project 3

Εκφώνηση: https://k08.chatzi.org/projects/project3/


### Προσωπικά στοιχεία

__Όνομα__: Δημάκης Αντώνιος

__Α.Μ.__: sdi1900047

### Ασκήσεις που παραδίδονται

Παραδίδονται όλες οι ασκήσεις και τα bonus.
Το tests για το δεύτερο bonus δεν βρίσκεται σε διαφορετικό αρχείο, απλά προστέθηκαν μερικές γραμμές στο υπάρχον test.

### Documentation

Άσκηση 1:<br>
Έχει γίνει η υλοποίηση με separate chaining και επίσης έχουν προστεθεί οι συναρτήσεις map_get_hash_function και map_get_compare για να
χρησιμοποιηθούν στην υλοποίηση του ADTGraph.<br>
Άσκηση 2:<br>
Η graph_insert_edge έχει απροσδιόριστη συμπεριφορά όταν υπάρχει ήδη ακμή ανάμεσα στους κόμβους.
Αφού απαντήθηκε ότι αυτό είναι αποδεκτό, το έκανα για να βελτιωθεί η πολυπλοκότητα (σε πυκνό γράφο) και να μην διατρέχουνται πάντα οι λίστες γειτνίασης για να βρεθεί πιθανή παλιά ακμή.<br>
Για την graph_shortest_path χρησιμοποιείται ο τύπος SearchNode που αποθηκεύει τις απαιτούμενες πληροφορίες (όπως η απόσταση, η προηγούμενη ακμή, κλπ.) για κάθε κορυφή, και συνδέεται με την κορυφή μέχω ενός map.<br>
Άσκηση 3:<br>
Έχει γίνει χρήση ADTList, ADTMap, ADTSet και ADTPriorityQueue.<br>
Τα records/κρούσματα κατατάσσονται σε sets σύμφωνα με την ημερομηνία τους, λαμβάνοντας υπ' όψιν και το id σε περίπτωση κοινής ημερομηνίας.<br>
Υπάρχει ένα συνολικό set όπου μπαίνουν όλα τα κρούσματα.<br>
Υπάρχουν επίσης sets που μπαίνουν κρούσματα μόνο μιας συγκεκριμένης χώρας, ασθένειας, ή συνδιασμού αυτών των δύο. Αυτά τα sets συνδέονται με τις αντίστοιχες χώρες/ασθένειες μέσω maps.<br>
Έτσι μπορούν να αναζητηθούν γρήγορα κρούσματα γνωρίζοντας συγκεκριμένες ημερομηνίες, και ψάχνοντας ή το σύνολο των δεδομένων ή ένα συγκεκριμένο υποσύνολο αν υπάρχουν περιορισμοί ως προς την ασθένεια, την χώρα, ή και τα δύο.<br>
Υπάρχει επίσης μια συνολική pqueue, που αποθηκεύει όλες τις ασθένειες σύμφωνα με το πλήθος των κρουσμάτων τους, ώστε να βρίσκονται γρήγορα οι ασθένειες με τα περισσότερα κρούσματα, καθώς και ένα map που συνδέει κάθε ασθένεια με τον αντίστοιχο κόμβο (PriorityQueueNode) σε αυτήν την pqueue, για να μπορεί αν γίνεται ενημέρωση του κόμβου όταν εισέρχονται ή αφαιρούνται κρούσματα.<br>
Υπάρχουν επίσης αντίχτοιχα pqueues για κάθε χώρα, για να βρίσκονται οι πιο συχνές ασθένειες για μια συγκεκριμένη χώρα, και ένα map που αντιστοιχεί χώρα και ασθένεια στον κατάλληλο κόμβο της κατάλληλης pqueue.<br>
Τέλος υπάρχει ένα map που αντιστοιχεί κάθε id στο κατάλληλο record/κρούσμα, για να γίνεται γρήγορα αφαίρεση με γνωστό μόνο το id.<br>
Οι δομές που αφορούν συγκεκριμένες χώρες/ασθένειες δημιουργούνται και καταστρέφονται δυναμικά.<br>
Στο ADTSet προστέθηκαν 3 συναρτήσεις:<br>
Η set_return_from_to, που επιστρέφει μια λίστα με τα στοιχεία από το from μέχρι το to (σύμφωνα με την compare) με πολυπλοκότητα O(logn) για σταθερό m, με n όλα τα στοιχεία και m αυτά που θα επιστραφούν.<br>
Οι set_count_greater_than, set_count_less_than, που μετρούν τα στοιχεία του set μεγαλύτερα από max ή μικρότερα από min, σύμφωνα με την compare, αντίστοιχα, με πολυπλοκότητα O(logn) ως προς το μέγεθος του set, ανεξάρτητα από το πλήθος των στοιχείων που μετρούνται.<br>
Στο ADTPriorityQueue προστέθηκε μία συνάρτηση, η pqueue_top_k που επιστρέφει μια ταξινομημένη λίστα με τις max{k, pqueue_size} μέγιστες εγγραφές στην pqueue, με πολυπλοκότητα Ο(k*logn).<br>
Δεν δημιουργήθηκε struct disease_monitor γιατί ούτως ή άλλω θα υπήρχε ένα global, άρα απλά ορίστηκαν ως global οι δομές που θα περιείχε.<br>